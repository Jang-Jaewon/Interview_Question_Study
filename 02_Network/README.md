# Network

- [HTTP 1.1과 HTTP 2.0의 차이점은?](#%EF%B8%8F-http-1.1과-http-2.0의-차이점은)
- [HTTP와 HTTPS의 차이점이 무엇인가요?](#%EF%B8%8F-http와-https의-차이점이-무엇인가요)
- [대칭키와 비대칭키가 무엇인가요?](#%EF%B8%8F-대칭키와-비대칭키가-무엇인가요)
- [SSL 통신의 동작방식은 어떻게 되는가?](#%EF%B8%8F-ssl-통신의-동작방식은-어떻게-되는가)
- [CORS는 무엇인가요?](#%EF%B8%8F-CORS는-무엇인가요)
- [CORS는 시나리오는 무엇이 있나요?](#%EF%B8%8F-CORS는-시나리오는-무엇이-있나요)
- [REST API란?](#%EF%B8%8F-rest-api란)
- [REST API를 설계할 때 주의할 점은?](#%EF%B8%8F-rest-api를-설계할-때-주의할-점은)
- [OSI 7계층 이란](#%EF%B8%8F-osi-7계층-이란)
- [웹브라우저에서 "google.com"을 입력하면 일어나는 일](#%EF%B8%8F-웹브라우저에-"google.com"을-입력하면-일어나는-일)

<br>

## 💡 HTTP 1.1과 HTTP 2.0의 차이점은?
> HTTP 1.1은 Persistent Connection 도입으로 기존 HTTP 1.0의 단점을 보완했지만, 다중 연결이 불가능하고, 요청과 응답이 순차적으로 이루어지는 단점이 존재했다. 또한 HTTP 1.1은 Pipelining 기술의 도입을 통해 Persistent Connection이 발생시키는 Latency를 부분적으로 보완할 수 있었지만, Head Of Line Blocking의 문제를 발생하였다. 이 밖에도 HTTP 1.1은 Header의 중복을 처리하지 않았기 때문에 불필요하게 큰 Header의 크기로 인하여 데이터의 낭비가 발생했다. HTTP 2.0은 기존 HTTP 1.1의 대체가 아닌 확장 개념으로 성능향상의 초점을 맞춰 1.1 버전의 한계를 보완하는데 목적을 가지고 있다. HTTP 2,0의 주요한 변화 중 하나는 Binary Framing 계층을 도입하여 데이터를 분할할 뿐만아니라 Bianry 형식으로 인코딩하여 전송 속도를 향상시키고, 오류를 감소시켰다. 뿐만아니라 프레이밍으로 분할시킴으로써 순서에 제약받지 않고 동시에 여러 응답을 stram으로 주고 받는 Multiplexing 방식을 도입해 Head Of Line Blocking의 문제를 해결하였다. 또한 Stream Prioritization과 Server Push 기술을 통해 효율성을 최적화하였고, Header의 크기를 압축하는 Header Compression을 통해 Header의 크기가 80% 이상 감소되었다.


### 추가적인 내용 기술
- HTTP 1.1은 Persistent Connection 도입으로 인해 Connection 마다 하나의 요청을 처리할 수 있게 되었다. Persistent Connection란 지정한 TimeOut 동안 Connection을 끊지 않는 방식을 의미한다.
- 단, Persistent Connection는 동시에 요청 전송이 불가능하고 요청과 응답이 순차적으로 이루어지도록 설계되어 있기 때문에 다수의 리소스(CSS, JS, Image)를 처리하기 위해서는 요청할 리소스 개수에 비례해 Latency가 발생된다.
- 또한 HTTP 1.0에서는 연결에 따른 요청에의 응답이 있어야만 다음 요청이 순차적으로 가능했지만 HTTP 1.1에서는 Pipelining 기술을 도입하였다.
- Pipelining 이란 하나의 Connection에 응답을 기다리지 않고, 순차적으로 여러 요청을 보내 그 순서에 맞춰 응답을 받는 방식을으로 Persistent Connection가 발생시키는 Latency를 부분적으로 보완할 수 있다.
- 단, Pipelining의 단점으로는 Head Of Line Blocking인데, 이는 선행되는 요청이 지연되면 그 다음 요청도 기다려야 하는 것이다. 쉽게 말해, 서버에서 처리가 끝났는데 먼저 선행되어야하는 요청이 처리되지않아 그 뒤에 응답들이 처리가 되었는데도 불구하고 대기를 타는 것이다.
- 이 밖에도 HTTP 1.1의 한계로는 연속된 요청일 경우, Header가 중복될 경우가 많은데 중복된 Header 값을 모두 매번 전송하기 때문에 주고 받는 불필요하게 큰 Header의 크기로 데이터 낭비가 존재했다. 
- HTTP 2.0은 기존 HTTP 1.1의 대체가 아닌 확장 개념으로 성능향상의 초점을 맞춰 1.1 버전의 한계를 보완하는데 목적을 가지고 있다.
- HTTP 2.0은 Binary Framing 계층을 도입하여 메시지 전송 방식을 변환시켰다. Binary Framing 계층은 Application 계층 내에서 작동하는데 데이터를 프레이밍화하여 분할할 뿐만아니라 기존의 일반 Text 형식아 아닌 Bianry 형식으로 인코딩하여 전송 속도를 향상시키고, 오류를 감소시켰다.
- 또한 프레이밍을 통해 요청을 Headers와 여러 Data로 분할시켰기 때문에 한 Connection으로 여러개의 응답을 순서에 상관없이 stream으로 주고 받아, Head Of Line Blocking의 문제를 해결하였다. 이를 Request and Response Multiplexing이라한다.
- 또한 HTTP 2.0에서는 Stream Prioritization을 도입하여, 리소스에 우선순위를 지정하여 중요도가 높은 리소스를 먼저 응답하게끔 설정이 가능하다.
- 이 밖에도 Server Push란 기능으로 인해 클라이언트가 요청하지 않은 정보일지라도 현재 요청으로 인하여 발생될 의존관계를 고려해서 추가 발생될 요청을 사전에 응답할 수 있다.
- 앞 서, HTTP 1.1에서 Header의 크기의 문제를 보완하기 위해 HTTP 2.0에서는 Header Compression를 도입하였다. 
- Header Compression는 Static Dynamic Table이라해서, 이미 보내져 중복된 Header값은 index만 나타내고, 중복되지 않은 데이터는 Huffman 인코딩 통해 Header를 전반적인 Header의 크기를 압축하는 것이다. 이를 통해 Header의 크기가 80% 이상 감소되었다고 한다.


<br>

## 💡 HTTP와 HTTPS의 차이점이 무엇인가요?
> HTTP는 "Hyper Text Transfer Protocol"의 약자로 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약이며, 80번 포트를 사용하고 있다. HTTP는 암호화가 되지 않은 평문 데이터를 전송하는 프로토콜이기 때문에, 민감한 개인정보 등을 주고 받으면 제3자가 정보를 조회할 수 있다는 취약점이 존재한다. 이에 HTTPS가 등장하게 되었는데, 기존의 HTTP에서 Secure Socket이 추가된 보안이 강화된 통신 프로토콜이다. HTTPS는 사용자가 싸이트에 보내는 정보들을 제 3자가 보지 못하게 암호화하고 접속한 싸이트가 신뢰할 수 있는 싸이트인지 판별함으로써 보안의 취약점을 강화하였다. 또한 HTTPS는 보안의 장점 뿐 아니라, 검색 엔진 최적화(SEO) 가산점을 받을 수 있기 때문에 서비스를 노출시키는데도 효과적이다.


### 추가적인 내용 기술
- HTTP는 Hyper Text를 통신하기 위한 규약으로 80번 포트를 사용하고, 상태를 유지하지 않는 Statless한 특징이 있다.
- HTTP의 구조는 Method, Path, Version, Headers, Body 등으로 구성되어 있다.
- HTTPS는 HTTP 기술에 취약점을 보완하여 보안을 강화시킨 통신 규약으로 443 포트를 사용한다.
- HTTP와 HTTPS의 가장 큰 차이점은 HTTPS가 가진 SSL 인증서이다. SSL 인증서는 공개키와 개인키를 통해 암호화 및 복호화를 하기 때문에 제 3자가 이를 취득하더라도 이를 해독할 수 없다.
- 또한 HTTPS는 TLS(전송 계층 보안) 프로토콜을 통해 전송 중 데이터가 통신하는 과정에서 무결성을 입증하고, 신뢰하고 있는 싸이트와 통신하고 있음을 검증시켜준다.
- 뿐만아니라, HTTPS는 검색 엔진 최적화(SEO)에 따라 가산점을 받기 때문에 서비스를 노출시키는데도 장점을 지닌다.
- 참고로 위에서 언급한 TLS와 SSL은 같은 것이다. 네스케이프에 의해 SSL이 발명되었고, 폭넓게 사용되어오다 표준화 기구인 IETF가 관리를 맡게되면서 이름만 TLS로 바뀐 것이다. 실제로 TLS라는 이름 보다는 SSL로 많이 불리고 있다.
- 또한 HTTPS와 SSL의 관계는 SSL 프로토콜 위에서 HTTPS 프로토콜이 작동되기 때문에 SSL을 좀 더 포괄적인 개념으로 이해해야 한다.


<br>

## 💡 대칭키와 비대칭키가 무엇인가요?
> 대칭키 암호화 방식은 클라이언트와 서버가 동일한 키를 가지고 복호화를 진행하는 것을 의미하는데, 연산속도가 빠르기 때문에 대용량의 데이터를 암호화시키는데 효과적인 암호화 방식이다. 비대칭키는 1쌍의 공개키와 개인키로 이뤄져 암호화 및 복호화하는 방식으로 보안에서 강점을 지니지만, 높은 컴퓨팅 파워가 필요로하기 때문에 속도가 느리고, 과부하를 일으킨다는 단점이 있다. 이에 실제 HTTPS 통신에서는 데이터 자체는 대칭키로 암호화 및 복호화 하지만, 이 대칭키를 서로 공유함에 있어서 비대칭키를 통해 암호화 및 복호화하는 혼합 방식을 채택했다.

### 추가적인 내용 기술
- 대칭키 암호화 방식은 클라이언트와 서버가 동일한 키를 가지고 복호화를 진행하는 것을 의미하는데, 연산속도가 빠르기 때문에 대용량의 데이터를 암호화시키는데 효과적인 암호화 방식이다. 
- 단, 클라이언트와 서버가 같은 대칭키를 가지고 있다는 것은 이 대칭키를 서로 통신하여 공유해야하는데, 이 과정에서 대칭키가 탈취된다면 데이터 복호화가 가능하기 때문에 보완이 취약점이 발생하게 된다는 한계점이 존재한다.
- 이에 고안된 비대칭키는 공개키와 개인키로 나뉜다. 공개키로 암호화된 데이터는 개인키로만 복호화가 가능하기 때문에 공개키가 탈취된다하더라도 데이터 복호화는 불가능하다.
- 또한 개인키로 암호화되어 클라이언트에 보내지는 데이터는 서버에게 받은 공개키로만 복호화가 가능하기 때문에 이를 통해 서버가 신뢰할 수 있는지 판별이 가능하다.
- 이에 속도가 빠른 대칭키를 통해 데이터를 암호화하고 복호화하지만, 클라이언트와 서버가 대칭키를 공유하는 방식에 있어 비대칭키가 활용하는 혼합된 방식을 사용함으로써 성능상의 이점과 보안상의 이점을 동시에 취하고 있다.


<br>


## 💡 SSL 인증서는 무엇이고 HTTPS 통신에서 어떻게 작동되는가?
> SSL 인증서에는 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)가 담겨있는데 이를 통해 접속한 서버가 신뢰할 수 있는 서버임을 인증기관(CA)를 통해 보장된다. 또한 SSL 인증서에는 서버측의 공개키 정보(공개키 내용, 공개키의 암호화 방법)가 존재하는데 이 공개키를 통해 암호화 또는 복호화를 진행한다.

### 추가적인 내용 기술
- 클라이언트가 서버에 접속 할 때, SSL 통신과정을 통해 서버는 클라이언트에게 SSL 인증서를 제공한다.
- 클라이언트는 서버에게 받은 SSL 인증서가 웹브라우저의 CA 리스트에 있는지 확인하여 포함되어 있다면, 해당 CA의 공개키를 이용하여 인증서를 복호화한다.
- CA의 개인키는 CA만 가지고 있기 때문에 서버가 제공한 인증서가 CA의 공개키로 복호화된다는 것은 CA의 인증을 받아 발급받은 인증서라는 것을 의미한다.
- 즉, SSL 인증서에는 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)가 담겨있는데 이를 통해 접속한 서버가 신뢰할 수 있는 서버임을 인증기관(CA)를 통해 보장된다. 
- 또한 SSL 인증서에는 서버측의 공개키 정보(공개키 내용, 공개키의 암호화 방법)가 존재하는데 이 공개키를 통해 암호화하여 서버에게 데이터를 전달한다.


<br>

## 💡 SSL 통신의 동작방식은 어떻게 되는가?
> SSL의 동작 방식은 악수, 전송, 세션 종료 3가지로 나뉘져있는데, 악수(Handshake)에서는 서버가 클라이언트에게 SSL 인증서를 전달하고, 서로가 사용할 수 있는 보안 방식을 공유 및 결정한다. 또한 악수(Handshake) 단계에서 pre master secret가 클라이언트와 서버에게 공유되는데, 이를 통해 클라이언트와 서버는 서로 session key를 생성한다. 세션 단계에서는 이미 서로 동일한 session key를 가지고 있기 때문에 대칭키 방식으로 실제 전달한 데이터를 암호화하고 복호화하는 과정이 발생한다. 세션 종료 단계에서는 데이터 전송이 끝났기 때문에 서로 SSL 통신이 끝났음을 알려주고, SSL 통신과정에서 사용한 session key를 폐기시킨다.

### 추가적인 내용 기술
- SSL의 통신의 동작 방식은 악수(Handshake), 전송, 세션 종료 3가지로 나뉘어져있다.
- 사람이 소통하기 앞서 서로의 존재를 확인하기 위해 인사를 하는 것처럼 네트워크 통신에 있어서도 악수(Handshake)가 먼저 일어난다.
- 맨 처음 이뤄지는 Client Hello 단계에서는 우선 클라이언트가 서버에 최초 접속을 시도하는 것을 의미한다. 이 때 클라이언트측에서 생성한 랜덤한 데이터와 함께 클라이언트가 지원하는 암호화 방식을 서버에게 알려준다.
- 그 다음 서버는 클라이언트에 대한 응답으로 Server Hello 단계가 이뤄지는데, 이 때 서버측에서 생성한 랜덤한 데이터와 함께 클라언트가 보낸 암호화 방식 중 하나를 채택해서 응답한다. 이 과정에서 SSL 인증서 또한 클라이언트에게 전달된다.
- 서버에게 SSL 인증서를 받은 클라이언트는 이 인증서가 CA를 통해 발급된 것인지 웹브라우저의 CA 리스트를 확인하는 절차를 가진다.
- CA 리스트에 이 인증서가 존재한다면 CA의 공개키를 이용해 인증서를 복호화한다. 이 과정을 통해 서버가 신뢰할 수 있는 서버인지 판별한다.
- 이후 클라이언트는 최초 자신이 서버에게 보낸 랜덤 데이터와 서버에게 받은 랜덤 데이터를 조합해 pre master secret 이라는 키를 생성한다. 
- 클라이언트가 pre master secret 키를 생성했다면, 서버가 준 인증서를 복호화해서 획득한 서버의 공개키를 통해 pre master secret 값을 암호화하고 서버에 전달한다. 그럼 서버는 자신의 개인키를 통해 클라이언트에게 받은 pre master secret 키를 복호화한다. 이를 통해 서로 같은 pre master secret 키 공유하게 된다.
- 이제 클라이언트와 서버는 일련의 과정을 통해 pre master secret 값을 master secret 값으로 만들고, master secret 값을 통해 session key를 생성한다.
- 이제 클라이언트와 서버는 악수(handshake) 단계의 종료를 서로에게 알린다.
- 악수(handshake) 단계가 이상 없이 끝났다면, 세션 단계가 이어진다. 여기서는 실제 데이터가 암호화되어 전송되고, 복호화되어 확인하는 통신 과정이 이뤄진다. 이 때 session key를 이용하여 대칭키 방식으로 암호화와 복호화가 이뤄진다.
- 마지막으로 세션 종료 단계에서는 서로 SSL 통신이 끝낫음을 알려주고, session key를 서로 폐기한다.


<br>

## 💡 CORS는 무엇인가요?
>  CORS란 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 자원에 접근할 수 있는 권한을 부여하도록 브라우저에게 알려주는 메카니즘이다. 과거 SOP(Same Origin Policy)에 의해 다른 출처의 자원이 공유되지 못하게 막아둔 것을 CORS 정책을 통해 공유가 가능하게 할 수 있다. CORS는 메커니즘은 요청 header에 담긴 Origin과 응답 header에 담긴 Access-Control-Allow-Origin가 일치하는지 웹브라우저가 평가하여 요청에 대한 응답을 처리할지, CORS 에러를 발생시킬지 판단한다. 


### 추가적인 내용 기술
- 원래 브라우저에서는 A라는 사이트에서 B라는 사이트에 요청을 보내고 받는 자원 공유가 보안 상의 이유로 금지되어 있었다. 이를 SOP(Same Origin Policy)라 하고 같은 출처(Origin)만이 자원 공유가 가능 했다.
- 여기서 같은 출처(same origin)란 데이터를 보내고 받는 각각의 위치(즉, 웹사이트랑 API의 주소 등)의 프로토콜, 호스트, 포트가 일치할 때를 의미하고 이 판단은 클라이언트나 서버가 아닌, 브라우저에서 판단한다.
- 참고로 보안 상의 이유라는 것은 XSS나 XSRF 등의 보안 취약점을 방어하기 위함이다.
  - XSS(Cross Site Scription, 사이트 간 스크립팅) : 관리자가 아닌 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 행위
  - XSRF(Cross Site Request Forgery, 사이트 간 요청 위조) : 사용자가 자신의 의지와는 무관하게 공격자가 이도한 행위(수정, 삭제, 등록 등)를 웹사이트에 요청하게하는 공격 행위
- 웹 생태계가 다양해지면서 여러 서비스들 간에 자유롭게 데이터가 주고 받아질 필요가 생기면서, SOP를 우회하는 등의 방식들이 초기 나타났지만, 합의된 출처들 간에 자원이 합법적으로 공유될 필요성이 커지게 되었다.
- 이에 W3C의 권장사항으로 CORS(Cross-Origin Resource Sharing)라는 정책이 발표되면서 허용된 다른 출처 간에 리소스를 공유할 수 있게되었다.
- CORS는 Request에 header에 Origin이라는 값과 Response의 header에 Access-Control-Allow-Origin가 같으면 웹브라우저가 SOP 정책에 위배되지 않다고 판단하고 자원을 공유시킬 수 있도록 해준다.

<br>

## 💡 CORS는 시나리오는 무엇이 있나요?
> CORS는 메커니즘은 요청 header에 담긴 Origin과 응답 header에 담긴 Access-Control-Allow-Origin를 웹브라우저가 비교하여 요청에 대한 응답을 처리할지, CORS 에러를 발생시킬지 판단하는 절차이다. 이에 CROS의 접근 제어 시나리오는 세부적으로 예비 요청(Preflight Request), 단순 요청(Simple Request), 인증 정보 포함 요청(Credentialed Request)으로 나뉜다. 예비 요청은 사전에 OPTIONS 매서드를 통해 웹브라우저에게 동일 출처인지 확인을 거친 후 본 요청을 보내는 방법이고, 단순 요청은 본 요청을 바로 보내면서 이러한 절차를 진행하는 차이를 가진다. 인증 정보 포함 요청은 더욱 보안을 강화시킨 방법으로 요청에 쿠키를 담을 수 있도록 옵션값을 지정해주는 CORS 시나리오를 의미한다.


### 추가적인 내용 기술
- CORS의 대표적인 시나리오는 예비 요청(Preflight Request), 단순 요청(Simple Request), 인증 정보 포함 요청(Credentialed Request) 으로 나뉜다.
- 예비 요청(Preflight Request)은 OPTIONS 매서드로 Origin을 실어 요청을 보내면, 서버에서 Access-Control-Allow-Origin에 Origin을 명시하여 응답한다. 이를 브라우저에서 출처가 같은지 확인한 뒤, 같으면 본 요청을 보내게된다. 다르다면, 브라우저가 CORS 에러를 띄운다.![](https://images.velog.io/images/jewon119/post/1647b882-f828-4b6a-8b2d-b59301256398/preflight.png)
- 단순 요청(Simple Request)은 예비 요청 과정을 생략하고, 바로 본 요청을 이뤄질 때 Origin을 요청을 보내고 서버에서 Access-Control-Allow-Origin를 명시하여 반환함으로써 이를 웹브라우저가 평가하는 방식이다.
- 단순 요청(Simple Request)은 요청 시, GEt, HEAD, POST 옵션만 사용 가능하고, 사용한 가능한 헤더의 종류 또는 Content-Type의 종류가 제한적이다. 
- 예를 들어, 단순 요청으로 PUT, DELETE 매서드로 요청이 가능하다면, 이미 서버에게 본 요청을 보내 자원을 수정하거나 삭제한 뒤에 웹브라우저에서 CORS 에러를 발생시키기 때문에 단순 요청은 여러 제약사항을 가지고 있다.![](https://images.velog.io/images/jewon119/post/9d441e03-c161-4855-9937-5f99c54c11e3/simplerequest.png)
- 인증 정보 포함 요청(Credentialed Request)은 보다 보안을 강화시킨 방식으로 쿠기를 담기 위해 지정하는 옵션이다.
- 즉, fetch나 비동기 API들은 기본적으로 쿠기를 담아서 요청을 보내지 않기 때문에 쿠기를 담을 수 있도록 옵션 값을 지정해주는 것이다. 이 옵션으로 same-origin(기본값), Include, Omit이 있다.
- same-origin은 같은 출처 간 요청에만 인증 정보를 담겠다는 기본으로 지정된 옵션 값이고, include는 모든 요청에 인증 정보를 담을 때 사용한다. omit은 모든 요청에 인증 정보를 담지 않을 때 사용하는 옵션이다.

<br>

## 💡 REST API란?
> REST API란 URI를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD 행위를 적용하는 것을 의미한다. 이에 REST API는 별도의 인프라를 구출할 필요가 없고, URI와 Method를 통해 쉽게 이해하고 사용 가능한 아키텍쳐란 점에 장점을 가진다. 단, REST API는 표준이 존재하지 않고, 사용할 수 있는 Method가 4가지 밖에 없다는 단점을 가지고 있다. 그럼에도 불구하고, REST API가 필요한 이유는 애플리케이션을 모듈, 기능별로 분리하기 쉽기 때문에 확장성이 높고, 어떤 다른 애플케이션 간에도 상호간 통신이 가능하단 담점이 있기 때문이다. 또한 서버에서 클라이언트 측에 필요한 데이터만 부분적으로 보내주면 되기 때문에 부담이 없고 유지보수성이 높기 때문이다.


### 추가적인 내용 기술
- REST API란 URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD 행위를 적용하는 것을 의미한다.
- 즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.
- 이에 REST한 방식으로 설계된 API를 RESTful API라 부르기도 한다.
- REST API는의 장점은 HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
- 또한 REST API는 URI와 Method를 통해 의도하는 바를 명확하게 나타내므로 쉽게 파악할 수 있고, HTTP 표준 프로토콜를 사용하는 모든 플랫폼에서 사용 가능하다.
- REST API의 단점은 명확한 표준이 존재하지 않고, 사용할 수 있는 Method가 4가지 밖에 없다.

<br>

## 💡 REST API를 설계할 때 주의할 점은?
> URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다. 슬래시 구분자(/)는 계층 관계를 나타내는데 사용하고, URI 마지막 문자로 슬래시(/)를 포함하지 않는다. 하이픈(-)은 URI가독성을 높이는데 사용하고, 언더바(_)는 사용하지 않는다. 파일 확장자는 URI에 포함시키지 않는다. 리소스 간 관계가 있는 경우, 소유 관계를 명확히 나타낸다. 단, 가급적 전달하고자하는 자원은 명사를 사용하되, 컨트롤 자원을 의미하는 경우 예외적으로 동사를 허용한다.


### 추가적인 내용 기술
- URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다. 행위는 포함하지 않는다.
> Bad Example http://example.com/Accounts-create/
> Good Example  http://example.com/accounts/  
- 슬래시 구분자(/)는 계층 관계를 나타내는데 사용하고, URI 마지막 문자로 슬래시(/)를 포함하지 않는다.
> Bad Example http://example.com/students/3/courses/
> Good Example  http://example.com/students/3/courses
- 하이픈(-)은 URI가독성을 높이는데 사용하고, 언더바(_)는 사용하지 않는다.
>Bad Example http://example.com/blogs/jewon119/posts/what_is_rest_api
>Good Example http://example.com/blogs/jewon119/posts/what-is-rest-api
- 파일 확장자는 URI에 포함시키지 않고, Accept header를 사용한다.
>Bad Example http://example.com/users/92/photo.jpg
>Good Example http://rexample.com/users/92/photo 
- 가급적 전달하고자하는 자원은 명사를 사용하되, 컨트롤 자원을 의미하는 경우 예외적으로 동사를 허용한다.
>Bad Example http://example.com/posts/duplicating
>Good Example http://example.com/posts/duplicat

### 특이사항
- REST API에서는 URI 마지막에 슬래시(/)를 포함하지 않는 것을 권장하는데, Django에서는 URI 마지막에 슬래시(/)를 포함하는 것을 권장한다.
- 이에 Django REST Framework에서는 Django의 권장 사항을 따라 슬래시(/)를 포함하는 것을 우선 추천하고 있다.


<br>

## 💡 OSI 7계층 이란
> Open Systems Interconnection의 약자로 네트워크에서 서로 이질적인 연결을 문제와 호환성의 해결하기 위해 국제 표준 기구(ISO)에서 7단계로 제시한 모델이다. 7계층으로 분리하여 제시한 이유는 통신이 일어나는 과정을 단계별로 파악할 수 있고, 특정한 곳에 문제가 발생해도 다른 단계의 장비 또는 모듈에 미치는 영향을 최소화하기 위해서이다. OSI 7계층은 맨 아래부터 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층으로 나뉜다.


### 추가적인 내용 기술
- 물리 계층은 이에 0과 1의 데이터를 아날로그 신호로 바꿔 전선으로 흘려 보내고(encoding), 아날로그 신호가 들어왔을 때 이를 0과 1의 데이터로 해석(decoding)하는 역할을 한다.
- 데이터 링크 계층은 여러 데이터가 서로 혼재되지 않도록 구분자(이더넷 헤더, 트레일러) 데이터 앞 뒤에 붙이는 프레이밍 작업이 이뤄지는 곳으로 데이터를 정확하게 식별하는데 역할을 한다.
- 또한 데이터 링크 계층은 이더넷 규칙을 활용하여 여러대의 장비 간에 데이터 전송에 있어 충돌이 발생되지 않도록 흐름을 제어하고, 스위치라는 장비를 통해 같은 네트워크 내에서 MAC주소를 통해 해당 기기로 데이터를 전송한다.
- 네트워크 계층은 IP주소를 이용하여 목적지 PC가 어떤 네트워크에 속해있는지 식별하고, 목적지 PC가 존재하는 네트워크까지 데이터가 전달될 수 있도록 데이터를 포워딩하는 역할이 이뤄진다.
- 데이터가 목적지까지 이동하는 과정에서 여러 네트워크를 거치는 것을 라우팅이라하는데, 라우터라를 장비가 네트워크 계층의 패킷을 열어 IP주소를 식별하고 도달 가능한 다른 라우터로 데이터를 전달 과정이 네트워크 계층의 역할이다.
- 전송 계층에서는 신뢰할 수 있는 통신을 위해 3-way-handshake을 진행하는 TCP와 정확도 보다는 빠른 속도를 요구할 때 사용하는 UDP가 존재하는 계층이다.
- 또한 전송 계층에서는 Port 번호가 패킷으로 감싸져 데이터를 전달하는데, 이를 통해 해당 응용프로그램에 데이터가 전달할 수 있도록 식별한다.
- 이후, 세션 계층에서는 세션 체결, 통신 방식 등을 결정하고, 표현 계층에서는 문자 코드, 압축, 암호화 등의 데이터 변환 작업을 이뤄진다.
- 마지막으로 응용계층에서는 각 애플리케이션에 요청에 맞는 프로토콜을 이용해 대응되는 데이터를 생성하고 해석한다.
- 이 때, 웹 사이트를 이용할 때는 HTTP 프로토콜, 파일을 전송할 때는 FTP 프로포콜, 메일을 보낼 때는 SMTP 프로토콜, 메일을 받을 때는 POP3라는 프로토콜을 사용한다.
- 또한 네트워크에서 컴퓨터나 네트워크 장비에 붙여진 이름을 기반으로 IP주소를 알아내는 것을 이름 해석(name resolution)이라하는데, 이를 위해 응용 계층에서 DNS 프로토콜을 사용한다.

<br>

## 💡 웹브라우저에서 "google.com"을 입력하면 일어나는 일
> 웹브라우저에서 "google.com"을 입력하면 웹 브라우저가 입력한 URI을 해석한다. 이후 HSTS목록을 조회하여 HTTP 요청을 보낼지, HTTPS 요청을 보낼지 결정한다. 이제 domain 주소로는 서버와 통신할 수 없기 때문에 이를 컴퓨터가 읽을 수 있는 IP 주소로 변환하는 과정이 이뤄진다. 우선, Browser cache, OS cache, Router cache, ISP cache를 순차적으로 접근해 해당 URI에 매핑된 IP주소를 찾으려고 시도한다. 여기서 IP를 획득하지 못했다면, DNS 질의하여 IP주소를 확인 한다. IP주소를 획득했다면, 클라이언트와 서버가 connection을 통해 서로 신뢰할 수 있는 과정을 진행한다. 이 과정에서 HTTP 요청이 이뤄졌다면, 3-way handshake로 연결을 설정하고, HTTPS 요청이 이뤄졌다면, TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다. 이후, 본 요청을 클라이언트에서 서버로 전송하면, 서버가 이를 처리하여 응답을 클라이언트에 전달한다. 이 응답에 따라 웹브라우저가 HTML 컨텐츠를 화면에 보여준다.

### 추가적인 내용 기술
- 웹브라우저에서 "google.com"을 입력하면, 웹 브라우저가 입력한 URI를 해석한다. 
- 이는 어떤 protocal, domain, port, path로 요청할 것인지 입력한 정보를 바탕으로 해석 및 분석하는 과정을 의미한다. 
- HSTS는 HTTPS protocal을 권장하기 위해 브라우저에 알리는 보안기능으로 HSTS 목록 조회를 통해 해당 요청을 HTTPS로 보낼지 판단한다.
- 이에 HSTS 목록에 해당 URI가 존재한다면 명시적으로 HTTP로 요청한다 할지라도 웹 브라우저에 의해 HTTPS 요청이 이뤄진다.
- 요청 프로토콜이 확정되었다면, domian 주소에 해당하는 IP주소를 찾기 위해 4가지 캐쉬 기록 순차적으로 확인한다.
- 맨 먼저 Browser cache에 질의하는데 방문했던 DNS 기록을 웹브라우저에서 일정 기간 저장하는 공간이다. 여기에 없다면, OS cache에 질의하여 운영체제가 저장하고 있는 DNS 기록(hosts 파일)에 접근하여 확인한다. 여기에도 없다면, Router cache를 탐색하고, 최종적으로 ISP cache를 뒤져 IP주소를 획득하기 위한 과정을 거친다.
- 4개의 영역에서 DNS 기록을 cache로 가지고 있는 이유는 DNS로 요청되는 네트워크 트래픽을 낮추고 데이터 전송 시간을 개선하는데 도움을 주기 때문이다.
- 위에 4개의 cache에 존재하지 않는다면, DNS에 요청한다. Root DNS 서버에서 Third-level DNS 서버까지 redirect하여 해당하는 URL의 IP주소를 반환받거나, Error를 발생시킬 때 까지 탐색을 거친다. 이러한 검색 방식은 recursive search라 부른다.
- IP주소를 확인했다면, Browser가 서버와 connection을 실시하는데, 본 요청을 보내기 전 클라이언트와 서버가 통신을 하여 서로를 확인하기 위한 절차이다. 이를 통해 서버가 현재 불능 상태가 아닌지 확인할 수 있다.
- 이 때, HTTP 요청이라면 3-way-handshake가 이뤄지고, HTTPS 요청이라면 TLS handshake가 이뤄진다. 
- 3-way handshake 또는 TLS handshake를 통해 연결이 확립되었다면, 클라이언트에서 본 요청이 이뤄지는데 클라이언트는 서버에게 GET 요청 사용해 서버에게 www.google.com의 index.html를 요구한다.
- 이 때, 정적처리는 웹서버(Apache, Microsoft(IIS), Sun, nginx 등)에서 처리하고, 동적처리라면 웹서버에서 바로 처리할 수 없기 때문에 WSGI 같은 미들웨어를 거쳐 서버로 요청이 전달된다. 이에 요청에 따라 필요한 처리가 완료하면 response를 생성하여 클라언트에게 전달한다.
- 응답을 받은 웹브라우저가 HTML 컨텐츠를 제공한다. 

<br>