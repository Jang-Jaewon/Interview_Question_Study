# Data Structure

- [배열과 연결리스트의 장단점은?](#%EF%B8%8F-배열과-연결리스트의-특징과-장단점은)
- [Stack(스택)과 Queue(큐)란?](#%EF%B8%8F-stack(스택)과-queue(큐)란)
- [Hash Table(해시테이블) 이란?](#%EF%B8%8F-hash-table(해시테이블)-이란)
- [해쉬 충돌과 이를 해결하는 방법은?](#%EF%B8%8F-해쉬-충돌과-이를-해결하는-방법은)
- [heap에 대해 설명해주세요](#%EF%B8%8F-heap에-대해-설명해주세요)
 
<br>

## 💡 배열과 연결리스트의 특징과 장단점은?
>  배열은 데이터를 순차적으로 저장하는 자료구조로 인덱스로 접근하기 때문에 조회에 있어서는 연결리스트보다 빠르지만, 삽입 및 삭제에 있어서는 연결리스트 보다 느리다. 연결리스트는 데이터와 위치 정보를 담은 포인터로 이뤄진 노드 형태이기 때문에 메모리를 미리 할당할 필요가 없어 삽입과 삭제에 있어서는 높은 효율성을 가진다. 단, 조회에 있어서 연결리스트는 다음 노드를 순차적으로 탐색하며 값을 찾아야하기 때문에 조회가 빈번이 이뤄질 경우에는 배열 보다 느리다.


### 추가적인 내용 기술
- 배열과 연결리스트는 모두 여러 데이터를 저장할 수 있는 자구조이다. 
- 배열은 데이터들이 순차적으로 저장되는 자료구조이기 때문에 메모리 주소가 연속되어야 한다. 
- 메모리 주소가 연속되어야 한다는 특성 때문에 임의로 배열의 크기를 늘리거나 줄이는 것이 불가능 하다는 특성이 존재한다. 
- 연결리스트는 노드(데이터와 위치를 가르키는 포인터 정보를 포함)로 연결된 자료구조다. 
- 연결리스트는 원소의 다음 위치를 포인터로 가르키기 때문에 배열처럼 메모리 상에 원소가 연속적으로 위치할 필요가 없어, 메모리를 미리 할당할 필요가 없다.
- 배열은 원소가 추가될 때, 미리 메모리 공간을 확보하지 못하면 모든 원소가 이동해야함으로 삽입에 있어서 속도가 느리고, 중간에 원소를 삭제할 때도 뒤에 원소를 앞으로 이동시켜야하기 때문에 효율성이 떨어진다.
- 반면 연결리스트는 원소를 추가할 때, 그 위치를 이전에 마지막 노드가 가르키면 되기 때문에 삽입이 빠르다. 삭제 또한 삭제되는 노드의 이전노드와 다음노드를 연결시키면 되기 때문에 빠르다.
- 단, 조회에 있어서는 인덱스로 바로 접근 가능하기 때문에 배열이 빠르다는 장점이 있다.
- 이에 삽입, 삭제가 빈번하다면 연결리스트를 쓰는 것이 효율적이고, 조회가 빈번하다면 연결리스트를 사용하는게 효율적이다.

![title](https://media.vlpt.us/images/jewon119/post/c2e4aca7-f435-4cdb-9662-c5b2ae39a1a4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.56.00.png)   
 
<br>

## 💡 Stack(스택)과 Queue(큐)란?
> 스택은 한쪽에서만 자료를 넣고 뺄 수 있는 LIFO(Last-In-First-Out) 형식의 선형 자료구조이다. 반면 큐는 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 FIFO(First-In-First-Out) 형식의 선형 데이터 구조이다. 스택은 재귀적 알고리즘에 주로 사용되고, 큐는 너비우선탐색(DFS)를 활용된다. 운영체제에서 프로그램이 화면에 나타나는 순서, 웹 브라우저의 뒤로가기 기능 같은 경우 스택의 사례이고, 은행창구 번호표 대기나, 운영체제의 태스크 스케쥴링은 큐의 대표적인 사용 사례이다.

### 추가적인 내용 기술
- 스택에서 데이터를 맨 위에 쌓는 행위를 push라하고, 맨 위에 데이터를 꺼내는 행위를 pop이라 한다.
- 예를 들어, 쌓여진 책 위에 책을 하나 더 쌓으면 이는 push이고, 마지막에 쌓아올린 것을 빼내면 pop이다.

```python
# push
def stack_push(stack, value):
    stack.append(value)
# pop    
def stack_pop(stack):
    last = stack.pop()
    return last
stack = [] # stack 생성
stack_push(stack, 5)
stack_push(stack, 6)
stack_push(stack, 7)
stack_push(stack, 8)
print(stack) # [5, 6, 7, 8]
last = stack_pop(stack)
print(last) # 8 
print(stack) # [5, 6, 7]
```

- 큐에서 데이터를 맨 뒤에 넣는 행위를 enqueue라하고, 데이터를 맨 앞에서 빼는 행위를 dequeue라 한다.
- 예를 들어, 계산대에서 줄을 뒤에서 서는 것이 enqueue이고, 맨 앞에사람이 계산을 마치고 나가는 것이 dequeue이다.
- python에서 큐를 구현하는 방법으로 Array.pop(0)도 가능하나 시간 복잡도가 높기 때문에 덱(deque) 라이브러리를 사용

```python
from queue import deque
# enqueue
def queue_push(q, value):
    q.append(value)
# dequeue
def queue_pop(q):
    front = q.popleft()
    return front
queue = deque() # queue 생성
queue_push(queue, 5)
queue_push(queue, 6)
queue_push(queue, 7)
queue_push(queue, 8)
front = queue_pop(queue)
print(front) # 5
print(list(queue)) # [6, 7, 8]
```

<br>

## 💡 Hash Table(해시테이블) 이란?
> 해쉬테이블이란 Key-Value 형태의 자료구로조 Key를 통해 데이터를 읽기 때문에 속도가 획기적으로 빠르고 보통 배열로 Hash Table을 구현할 수 있다. 또한 해쉬테이블은 해쉬 함수에 Key를 대입하여 해쉬값을 반환 받아, 이 위치에 데이터를 저장하는 방식이다. 해쉬 테이블은 평균적으로 O(1)  시간 복잡도를 가지나, 이 때 평균적이란 의미는 충돌이 발생하지 않을 때를 말한다. 이에 충돌이 발생되는 최악의 경우에는 O(N)의 시간 복잡도를 가진다.

### 추가적인 내용 기술
- 해쉬테이블은 Key-Value 형태의 자료구로조 Key를 통해 데이터를 읽어오기 때문에 속도가 빠르다. 
- 이미 python에서는 Dictionary가 해쉬 테이블의 구조를 갖고 있다.
- 해쉬 테이블은 데이터를 CRUD하는 속도가 빠르고, Key가 이미 존재하는지 중복을 처리가 쉽다는 장점이 있다.
- 단점으로는 충분한 저장 공간을 확보해두어야하기 때문에 비교적 저장 공간이 많이 필요하고, 여러 Key에 해당하는 주소가 동일할 경우 충돌을 막기 위한 방편이 필요하다.
- 이에 해쉬 테이블의 주 용도는 CRUD가 빈번한 경우, 검색이 자주 일어나는 경우, 캐쉬를 구현할 때 활용된다.
- 예를 들어, 스마트폰의 주소록은 해쉬로 개념과 동일하다. 사람을 주소록에서 검색하면, 전화번호, 주소, email 등을 모두 빠르게 확인할 수 있다.
- 해쉬 테이블은 삽입, 삭제, 조회에 있어서 평균적으로 O(1)의 시간복잡도를 가진다. 이는 배열과 연결리스트보다 높은 효율성을 가진다는 의미이다.
- 배열의 경우 조회는 O(1), 삽입 및 삭제는 O(N)의 시간 복잡도를 가지고, 연결 리스트의 경우 조회는 O(N), 삽입 및 삭제는 O(1)의 시간복잡도를 가지기 때문이다.
- 단 해쉬 함수에 Key를 대입하여 반환받은 해쉬값이 중복되는 충돌이 발생할 경우가 있다. 이 때에는 충돌을 해결하기 위해 Open Hashing 기법 또는 Close Hashing 기법을 사용한다. 
- 이런 충돌이 발생하는 최악의 경우의 해쉬테이블의 시간복잡도는 O(N)의 시간복잡도를 가지게 된다.

<br>

## 💡 해쉬 충돌과 이를 해결하는 방법은?
> 해쉬 테이블은 빠르다는 장점이 있지만, hash value의 중복으로 인한 충돌 현상이 발생할 수 있다. 즉, key를 가지고 hash function을 이용해 저장할 공간을 지정하는데, 이 때 같은 index 위치를 가르키면 갚이 덮어씌어져 버리기 때문이다. 이런 중복 현상으로 인한 충돌 문제를 해결하기 위해 Close Hashing방식의 Chaining 기법 또는 Open Hashing 방식의 Linear Probing 기법을 사용한다. Chaining 기법은 충돌이 발생할 경우, 연결 리스트를 만들어 값을 저장하는 방식이다. Chaining는 연결리스트를 위한 공간이 별도로 필요하고, 클러스터 현상으로 인해 검색 속도가 지현될 가능성이 존재한다. Linear Probing 기법은 충돌이 발생할 경우, 가장 가까운 빈 공간에 데이털르 저장하는 방식이다. 반면, Linear Probing 기법은 저장공간 활용도가 높지만, 데이터 길이가 많이 늘어나는 것에 대한 별도의 준비를 해야하기 때문에 저장할 데이터가 적을 때 더 유리하다.

### 추가적인 내용 기술
- 사실 해쉬 테이블의 시간복잡도는 평균적으로 발생하는 시간복잡도와 최악의 경우의 시간 복잡도가 존재한다.
- key값의 0번 index의 값을 ord 함수로 처리하여 특정 수로 나눈 뒤, 이를 hash value로 사용하여 저장하는 해쉬 테이블이 있다고 가정해보자.
- key값이 'Jeawon'과 'Jisu'가 있다면, 둘다 'J'를 ord 함수로 처리하기 때문에 74를 반환받는다. 이를 hash function에 넣어 5로 나눈 몫을 index로 저장한다.
- 이러면, 이미 저장된 index에 또 다시 저장이 발생하기 때문에 Data가 덮어씌어지는 충돌이 발생한다.
- 이런 충돌을 해겨하기 위한 방법으로 Close Hashing방식의 Chaining 기법 또는 Open Hashing 방식의 Linear Probing 기법을 사용한다.
- Chaining은 해쉬 테이블 공간 외의 새로운 공간을 마련하여 충돌이 발생 시 연결 리스트 자료 구조를 사용해 데이터를 저장하는 기법이다. 
- 즉, Chaining은 상대적으로 메모리 사용량이 낮고 공간을 확보할 필요가 없지만, 클러스터 현상(쏠림 현상)이 생겨 검색 속도가 낮아질 수 있고, 연결 리스트를 위한 공간이 따로 필요하다.
- Linear Probing 기법은 해쉬 테이블 저장 공간 안에서 충돌 문제를 해결하는 대표적인 방식으로, 우선 충돌이 발생하면 가장 가까운 빈 공간에 이를 배치한다.
- 이에 Linear Probing 기법은 hash adress의 다음 adress부터 맨 처음 나오는 빈 공간에 저장하는 방식이기 때문에 저장공간 활용도가 높지만, 데이터 길이가 많이 늘어나는 것에 대한 별도의 준비를 해야 한다.

<br>

## 💡 heap에 대해 설명해주세요
> heap이란 데이터에서 최대값과 최소값을 빠르게 찾기위해 고안된 완전 이진트리 형태의 자료구조이다. 힙은 max heap과 min heap이라는 2가지 구조를 가지는데, max heap의 각 부모노드는 자식노드들 보다 항상 크거나 최소한 같고, min heap의 부모노드는 자식노드들 보다 항상 작거나 최소한 같다. heap을 사용하는 이유는 큐나, 배열에 데이터를 넣고 최대값이나 최소값을 찾으려면 최악의 경우 O(N)의 시간복잡도를 가지는데, heap을 사용하면 O(log N)으로 시간복잡도가 현격하게 줄어들기 때문이다.

### 추가적인 내용 기술
- heap과 이진트리는 모두 이진트리 구조를 사용하는데 있어 공통점이 존재하나, heap 구조는 자식 노드보다 부모노드가 크거나 같고, 또는 작거나 같다. 또한 heap은 자식노드들 끼리는 어느 것이든 클 수 있고, 정렬되지 않는다. 
- 이에 반해 이진트리는 자식노드가 부모노드보다 크면 오른쪽, 작으면 왼쪽으로 배치된다. 
- 이진탐색트리는 탐색을 위한 구조이고, heap은 최소값 또는 최대값을 빠르게 찾기 위해 고안된 구조이기 때문이다.

```python
# Min Heap(최소힙) : 각 부모노드는 자식노드들 보다 항상 작거나 최소한 같다.
import heapq
data = [21, 67, 33, 13, 40, 89, 71, 19]
min_heap = list()
heapq.heapify(min_heap)
# heappush를 이용하여 데이터 삽입
for i in data:
  heapq.heappush(min_heap, i)
print(min_heap) # [13, 19, 33, 21, 40, 89, 71, 67] 👈 최소힙  
# 최소힙 활용
print(heapq.nlargest(3, min_heap)) # [89, 71, 67] 👈 최소힙에서 큰 수 3개
print(heapq.heappop(min_heap)) # 13 👈 최소힙에서 최소값 제거
print(min_heap) # [19, 21, 33, 67, 40, 89, 71] 👈 최소값 제거 후 heap 상태
```

```python
# Max Heap(최대힙) : 각 부모노드는 자식노드들 보다 항상 거나 최소한 같다.
import heapq
data = [21, 67, 33, 13, 40, 89, 71, 19]
data = [-x for x in data] # 👈 Heapq 라이브러리로 최대힙을 간단히 구현하기 위해 음수로 변경
print(data) # [-21, -67, -33, -13, -40, -89, -71, -19]
max_heap = list()
heapq.heapify(max_heap)
# heappush를 이용하여 데이터 삽입
for i in data:
  heapq.heappush(max_heap, i)
# 최대힙 활용
print(heapq.nlargest(3, max_heap)) # [-13, -19, -21] 👈 최대힙에서 가장 작은 수 3개
print(heapq.heappop(max_heap)* -1) # 89 👈 최대값 제거
print(max_heap) # [-71, -40, -67, -19, -21, -33, -13] 👈제거 후 최대힙
```
